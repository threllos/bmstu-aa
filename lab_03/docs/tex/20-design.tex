\chapter{Конструкторская часть}

\section{Разработка алгоритмов}

На рисунках \ref{img:comb}, \ref{img:insert} и \ref{img:pancake} представлены схемы алгоритмов сортировки расческой, вставками и блинной соответственно.
На рисунке \ref{img:pancake-alt} представлены схемы дополнительных алгоритмов, использующихся в блинной сортировке.

\includeimage{comb}{f}{H}{0.5\textwidth}{Схема алгоритма сортировки расческой}
\includeimage{insert}{f}{H}{0.7\textwidth}{Схема алгоритма сортировки вставками}
\includeimage{pancake}{f}{H}{0.7\textwidth}{Схема алгоритма сортировки блинной}
\includeimage{pancake-alt}{f}{H}{0.8\textwidth}{Схемы алгоритмов поиска максимального индекса и перестановки элементов в массиве}

\section{Модель вычислений}

Для последующего вычисления трудоемкости необходимо ввести модель вычислений:
\begin{enumerate}
    \item[1)] операции из списка (\ref{for:opers}) имеют трудоемкость 1;
        \begin{equation}
            \label{for:opers}
            +, -, =, +=, -=, ==, !=, <, >, <=, >=, [], ++, {-}-
        \end{equation}
    \item[2)] операции из списка (\ref{for:opers2}) имеют трудоемкость 2;
        \begin{equation}
            \label{for:opers2}
            *, /, \%, *=, /=, \%=
        \end{equation}
    \clearpage
    \item[3)] трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
        \begin{equation}
            \label{for:if}
            f_{if} = f_{\text{условия}} +
            \begin{cases}
            f_A, & \text{если условие выполняется,}\\
            f_B, & \text{иначе.}
            \end{cases}
        \end{equation}
    \item[4)] трудоемкость цикла рассчитывается, как (\ref{for:for});
        \begin{equation}
            \label{for:for}
            f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
        \end{equation}
	\item[5)] трудоемкость вызова функции равна 0.
\end{enumerate}

\section{Трудоемкость алгоритмов}

Обозначим во всех последующих вычислениях размер массивов \mbox{как N}.

\subsection{Алгоритм сортировки расческой}

Рассмотрим трудоемкость реализации алгоритма сортировки расческой.

Трудоемкость сортировки расческой состоит из:
\begin{enumerate}
	\item[1)] предварительных расчетов с трудоемкостью \ref{for:k2};
    \begin{equation}
    \label{for:k2}
        f(N) = 1 + 2
    \end{equation}
	\item[2)] двойного цикла, трудоемкость которого равна \ref{for:k1}, где $t$ --- фактор, в нашем случае 1.247. 
    \begin{equation}
    \label{for:k1}
        f(N) = \underbrace{1}_{\text{срав}} + log_t(N) \cdot (\underbrace{1}_{f_\text{иниц}} + \underbrace{2}_{f_\text{срав}} + 9N + \underbrace{1}_{f_\text{инк}}) + \underbrace{2}_{f_\text{деления}}
    \end{equation}
\end{enumerate}

Трудоемкость при лучшем случае (отсортированный массив) определяется формулой \ref{for:t1}.
\begin{equation}
\label{for:t1}
    f(N) = log_t(N) \cdot (4 + N) + 3
\end{equation}

Однако стоит учитывать, что при факторе $\approx$ 1.3, трудоемкость аппроксимируется следующим образом \ref{for:t2}, где $C$ --- некая константа. 
\begin{equation}
\label{for:t2}
    log_t(N) \cdot (4 + N) + 3 \approx C \cdot log(N) \cdot N \approx O(N \cdot log(N))
\end{equation}

В работе \cite{byte_ocr} сообщается о абстрактной аппроксимации и просьбе быть <<оптимистичными>>. 
Наличие в рассуждении <<просьбы>> является минусом, так как читателю придется взять на <<веру>> сказанное.
В работе \cite{comb_cocktail_counting_sort_compare} ведется рассуждение о выводе худшего случая экспериментальным
путем, однако стоит сказать, что экспериментальный путь не является гарантией полученной асимптотики.
В работе \cite{kolmogorov_complexity} вводится математический расчет нижней границы худшего случая. В данной 
работе приводится огромное количество аппроксимаций.
В работе \cite{simd} ведется разговор о приближении асимптотики худшего случая.
В работе \cite{dobosiewicz_shaker_sort} приводится матемаческий расчет асимпотики среднего случая, 
указание о том, что средний случай рассчитать сложнее, чем худший.
Доказательство асимптотики среднего и худшего случая.

Стоит обратить внимание, что в перечисленных работах происходит расчет худшего случая, но не приводятся конкретные примеры. 

Трудоемкость при худшем случае \ref{for:t4}.
\begin{equation}
\label{for:t4}
    f(N) =log_t(N) \cdot (4 + 9N) + 3 \approx O(N^2)
\end{equation}

\subsection{Алгоритм сортировки вставками}

Рассмотрим трудоемкость реализации алгоритма сортировки вставками.

Алгоритм сортировки вставками состоит только из двойного \mbox{цикла \ref{for:t3}}.
\begin{equation}
\label{for:t3}
    f_{\text{вставок}} = f_{\text{цикла с вложенностью 2}}
\end{equation}

Рассчитаем трудоемкость для вложенного цикла по формуле \ref{for:t5}.
\begin{equation}
\label{for:t5}
    f_{\text{цикла с вложенностью 2}} = 1 + 1 + N \cdot (1 + 6 + \frac{N + 1}{2} \cdot 8 + 1) + 1
\end{equation}

Трудоемкость при лучшем случае (отсортированный массив) \ref{for:t6}.
Алгоритм ни разу не войдет во внутренний цикл.
\begin{equation}
\label{for:t6}
    3 + N \cdot (\frac{N + 1}{2} \cdot 0 + 8) = 3 + 8N \approx O(N)
\end{equation}

Трудоемкость при худшем случае (отсортированный в обратном порядке массив) \ref{for:t7}.
Алгоритм будет полностью проходить внутренний цикл каждый раз.
\begin{equation}
\label{for:t7}
    3 + N \cdot (8 + \frac{N + 1}{2} \cdot 8) = 3 + 8N + 8N \cdot \frac{N + 1}{2} \cdot 8 \approx O(N^2)
\end{equation}

\subsection{Алгоритм блинной сортировки}

Рассмотрим трудоемкость реализации алгоритма блинной сортировки.

Этот алгоритм сортировки состоит только из двойного цикла, соответственно общая трудоемкость вычисляется по формуле \ref{for:t7}.
\begin{equation}
\label{for:t7}
    f_{\text{блинная}} = f_{\text{цикла с вложенностью 2}}
\end{equation}

Рассчитаем трудоемкость для вложенного цикла \ref{for:t8}.
\begin{equation}
\label{for:t8}
    f_{\text{цикла с вложенностью 2}} = 1 + 1 + N \cdot (3 + 5 \cdot N + 1 + 1 + 4 \cdot 2 \cdot N) + 1
\end{equation}

Трудоемкость при лучшем случае (алгоритм ни разу не сделает переворот) \ref{for:t9}.
\begin{equation}
\label{for:t9}
    3 + N \cdot (\frac{N + 1}{2} \cdot 0 + 8) = 3 + 4N + 5N^2 \approx O(N^2)
\end{equation}

Трудоемкость при худшем случае (отсортированный в обратном порядке массив) \ref{for:t10}.
Алгоритм будет полностью проходить внутренний цикл каждый раз:
\begin{equation}
\label{for:t10}
    3 + N \cdot (8 + \frac{N + 1}{2} \cdot 8) = 3 + 9N + 13N^2 \approx O(N^2)
\end{equation}

Стоит отметить, что асимптотики худшего и лучшего случаев совпадает.

\section*{Вывод}

На основе формул и теоретических данных, полученных в аналитическом разделе, были спроектированы схемы алгоритмов.
Для каждого из них были рассчитаны и оценены лучшие и худшие случаи.
