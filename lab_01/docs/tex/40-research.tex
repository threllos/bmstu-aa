\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программы, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Тестирование выполнялось на устройстве со следующими техническими характеристиками:
\begin{itemize}
	\item Операционная система: Windows 11 x64 \cite{windows}.
	\item Память: 8 GiB.
	\item Процессор: AMD Ryzen 5 3550H \cite{amd}.
\end{itemize}

Замеры проводились на ноутбуке, включенном в сеть электропитания.
Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, окружением, а также непосредственно системой тестирования.

\section{Пример работы программы}

На рисунке \ref{img:preview} представлен результат работы программы.

\img{50mm}{preview}{Пример работы программы}

\section{Время выполнения алгоритмов}

Результаты тестирования приведены в таблице \ref{tbl:times}.
Прочерк в таблице означает, что тестирование для этого набора данных не выполнялось.
На рисунках \ref{plt:iter-rec} и \ref{plt:l-dl} приведены зависимости времени работы алгоритма от длины строк. 

\begin{table}[h!]
	\begin{center}
		\caption{Время работы алгоритмов}
		\label{tbl:times}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			& \multicolumn{4}{c|}{\bfseries Время работы, нс}           \\ \cline{2-5}
			\bfseries Размер & \bfseries Л.Итер. & \bfseries Д.Л.Итер. & \bfseries Д.Л.Рек. & \bfseries Д.Л.Рек.кэш
			\csvreader{assets/csv/times.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv&\csvcolv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=len,y=dl-iter,col sep=comma]{assets/csv/times.csv};
			\addplot table[x=len,y=dl-recurs-cash,col sep=comma]{assets/csv/times.csv};
			\legend{Итеративный, Рекурсивный с кэшем}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы алгоритма вычисления расстояния Дамерау-Левентштейна от длины строк (итеративный и рекурсивный с кэшем)}
	\label{plt:iter-rec}
\end{figure}
\clearpage

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=len,y=l-iter,col sep=comma]{assets/csv/times.csv};
			\addplot table[x=len,y=dl-iter,col sep=comma]{assets/csv/times.csv};
			\legend{Левентштейн, Дамерау-Левентштейн}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы алгоритма вычисления расстояния Левентштейна и Дамерау-Левентштейна от длины строк (оба итеративные)}
	\label{plt:l-dl}
\end{figure}

\section{Использование памяти}

Далее будем считать, что $C()$ -- оператор вычисления размера.
А n и m -- длины строк $S_1$ и $S_2$ соответственно.

\subsection{Нерекурсивные алгоритмы}

Размер выделяемой памяти:
\begin{itemize}
	\item $n + m$ -- входные строки;
	\item $2 \cdot C(int)$ -- длины строк;
	\item $2 \cdot C(slice)$ -- буферы значений;
	\item $2 \cdot C(int) $ -- вспомогательные переменные в циклах.
\end{itemize}

Общая затраченная память равняется: $n + m + 4 \cdot C(int) + 2 \cdot C(slice)$.

В алгоритме Дамерау-Левентштейна добавляется еще один буфер, для проверки перестановки.
Поэтому размер выделяемой памяти, относительно простого алгоритма Левентштейна, изменится только в вычисляемой памяти для буферов: $3 \cdot C(slice)$.

Итоговое количество затраченной памяти равняется: $n + m + 4 \cdot C(int) + 3 \cdot C(slice)$.

\subsection{Рекурсивные алгоритмы}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящий строк $n + m$.

Для каждого вызова функции выделяемая память:
\begin{itemize}
	\item $n + m$ -- входные строки;
	\item $4 \cdot C(int) $ -- вспомогательные переменные.
\end{itemize}

Общая затраченная память равняется: $(n + m) \cdot (n + m + 4 \cdot C(int))$.

В рекурсивном алгоритме с кэшем дополнительно выделяется память под матрицу значений: $n \cdot m \cdot C(int)$, а так же в каждую функцию передается кэш -- $С([][]int)$.

Итоговое количество затраченной памяти равняется: $(n + m) \cdot (n + m + 4 \cdot C(int) + C([][]int)) + n \cdot m \cdot C(int)$.

\section*{Вывод}

В данном разделе были сравнены реализованные алгоритмы по памяти и по времени.
Рекурсивный алгоритм Дамерау-Левентштейна работает на порядор дольше, чем итеративная реализация этого же алгоритма.
Время работы рекурсивного алгоритма увеличивается в геометрической прогресии с ростом размера строк.
Алгоритм Левентштейна работает быстрее и затрачивает меньше памяти, чем модификация Дамерау.
По расходу памяти лучше всего показал себя рекурсивный алгоритм, так как для итеративных алгоритмов выделяется память под буферы.