\chapter{Конструкторская часть}

В данном разделе представлены схемы и трудоемкости реализуемых алгоритмов.

\section{Разработка алгоритмов}

%TODO: подумать и перефразировать
На рисунке \ref{img:mul_class} и \ref{img:mul_win} представлены схемы стандартного алгоритма и алгоритма Винограда умножения матриц.
На рисунке \ref{img:mul_win-alt} представлены схемы дополнительных алгоритмов, использующихся в алгоритме Винограда.

\img{150mm}{mul_class}{Схема стандартного алгоритма умножения матриц}
\clearpage
\img{190mm}{mul_win}{Схема алгоритма Винограда умножения матриц}
\clearpage
%TODO: заголовок переделать
\img{190mm}{mul_win-alt}{Дополнительные алгоритмы}
\clearpage

\section{Модель вычислений}

Для последующего вычисления трудоемкости необходимо ввести модель вычислений:
\begin{enumerate}
    \item операции из списка (\ref{for:opers}) имеют трудоемкость 1;
        \begin{equation}
            \label{for:opers}
            +, -, /, *, =, +=, -=, ==, !=, <, >, <=, >=, [], ++, {-}-
        \end{equation}
    \item трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
	\begin{equation}
        \label{for:if}
        f_{if} = f_{\text{условия}} +
        \begin{cases}
        f_A, & \text{если условие выполняется,}\\
        f_B, & \text{иначе.}
        \end{cases}
	\end{equation}
\item трудоемкость цикла рассчитывается, как (\ref{for:for});
    \begin{equation}
        \label{for:for}
        f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
    \end{equation}
	\item трудоемкость вызова функции равна 0.
\end{enumerate}

\section{Трудоёмкость алгоритмов}

Обозначим во всех последующих вычислениях размерность матрицы $A$ как $n \times k$, а матрицы $B$ как $k \times m$.

\subsection{Стандартный алгоритм умножения матриц}

Трудоёмкость стандартного алгоритма умножения матриц состоит из:
\begin{itemize}
	\item внешнего цикла по $i \in [1 \dots n]$;
	\item цикла по $j \in [1 \dots m]$;
	\item скалярного умножения двух векторов -- цикл по $k \in [1 \dots k]$.
\end{itemize}

%TODO: строчка как-то хуево звучит
Трудоёмкость стандартного алгоритма равна трудоёмкости внешнего цикла, можно вычислить ее, подставив циклы тела (\ref{for:base}):
\begin{equation}
	\label{for:base}
	f_{base} = 2 + n \cdot (4 + m \cdot (4 + 11k)) = 2 + 4 \cdot n + 4 \cdot nm + 11 \cdot nmk \approx 11 \cdot nmk
\end{equation}

\subsection{Алгоритм Винограда}

%TODO: список хуево
Трудоёмкость алгоритма Винограда состоит из:
\begin{itemize}
	\item формирования массива сумм произведений пар соседних элементов строк матрицы A;
	\item формирования массива сумм произведений пар соседних элементов строк матрицы B;
	\item цикла заполнения ячеек матрицы C для чётных размеров;
    \item дополнительный цикл, если размер матрицы нечётный.
\end{itemize}

% TODO: вообще все формулы переделать
Формирование массива сумм произведений пар соседних элементов строк матрицы A можно посчитать как \ref{eq:rf}:
\begin{equation}
    \label{eq:rf}
	\begin{array}{c}
	f_1 = 2 + n  \cdot(2 + 4 + q/2  \cdot (4 + 1 + 6 + 3  \cdot 2 + 2)) =  \\
		19/2 \cdot nm + 6 \cdot n + 2 ;
	\end{array}
\end{equation}

Формирования массива сумм произведений пар соседних элементов строк матрицы B можно посчитать как \ref{eq:cf}:
\begin{equation}
    \label{eq:cf}
	\begin{array}{c}
	f_2 = 2 + n  \cdot(2 + 4 + q/2  \cdot (4 + 1 + 6 + 3  \cdot 2 + 2)) =  \\
		19/2 \cdot nm + 6 \cdot n + 2 ;
	\end{array}
\end{equation}

Цикла заполнения ячеек матрицы C для чётных размеров можно посчитать как \ref{eq:wmul}:
\begin{equation}
    \label{eq:wmul}
	\begin{array}{c}
	f_3 = 2 + n \cdot (2 + 2 + m \cdot (2 + 7 + 4 + q/2 \cdot (4 + 1 + 12 + 5 + 5 \cdot 2))) = \\
		32/2 \cdot nqm + 13 \cdot nm + 4 \cdot n + 2 ;
	\end{array}
\end{equation}

Дополнительный цикл \ref{eq:even}:
\begin{equation}
	\label{eq:even}
	f_4 =  3 + \begin{cases}
	0, & \text{чётная,}\\
	2 +4 \cdot n + 13 \cdot nm, & \text{иначе.}
	\end{cases}
\end{equation}

Итого, трудоёмкость в лучшем случае (\ref{eq:best}):
\begin{equation}
    \label{eq:best}
    f_{best} = 10nmk
\end{equation}

Трудоёмкость в худшем случае (\ref{eq:worst}):
\begin{equation}
    \label{eq:worst}
    f_{worst} = 8nmk
\end{equation}

\subsection{Оптимизированный алгоритм Винограда}

Данный алгоритм можно оптимизировать:
\begin{enumerate}
	\item заменив выражения вида \texttt{a = a + ...} на \texttt{a += ...};
	\item введя промежуточный буфер для подсчета промежуточных значений;
	\item сделав в циклах по k шаг 2, избавившись тем самым от двух операций умножения на каждую итерацию.
\end{enumerate}

%TODO: написить
Тогда трудоемкости выглядят так:
...

%TODO: тут тоже переделать
Итого, трудоёмкость в лучшем случае (\ref{eq:best-opt}):
\begin{equation}
    \label{eq:best-opt}
    f_{best} = 9nmk
\end{equation}

Трудоёмкость в худшем случае (\ref{eq:worst-opt}):
\begin{equation}
    \label{eq:worst-opt}
    f_{worst} = 7nmk
\end{equation}

\section*{Вывод}

На основе формул и теоретических данных, полученных в аналитическом разделе, были спроектированы схемы алгоритмов.
Для каждого из них были рассчитаны и оценены лучшие и худшие случаи.
